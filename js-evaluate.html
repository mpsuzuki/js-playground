<html>
  <head>
    <style>
      table, tr, td, th {
        border-collapse: collapse;
        border: 1px solid black;
      }
      div.setting > input {
        margin: 4px;
      }
      #inputForPrompt {
        width: 400px;
      }
    </style>
  </head>
  <body>
    <div class="setting">
      <input type="file" id="fileSelector" multiple>
      <br>
      <input type="text" id="inputForPrompt" placeholder='[["test1-prompt1", "test1-prompt2"], ["test2-prompt1", ...], ... ]'>
      <input type="radio" name="input_data_format" id="as_json" value="as_json" checked><label for="as_json">JSON</label>
      <input type="radio" name="input_data_format" id="as_csv" value="as_csv"><label for="as_csv">CSV</label>
      <br>
      <input type="button" id="startEvaluate" value="evaluate">
    </div>
    <br>
    <div class="evaluated">
      <table>
        <thead></thead>
        <tbody></tbody>
      </table>
    </div>
    <script>
      let elmFileSelector = document.getElementById("fileSelector");
      let elmInputDataAsJson = document.getElementById("as_json");
      let elmInputDataAsCsv = document.getElementById("as_csv");
      let elmStartEvaluate = document.getElementById("startEvaluate");
      let elmTABLE = document.getElementsByTagName("table")[0];
      let elmTHEAD = document.getElementsByTagName("thead")[0];
      let elmTBODY = document.getElementsByTagName("tbody")[0];
      let elmInputForPrompt = document.getElementById("inputForPrompt");

      let progFragments = {};
      let strJsonForPrompt = "";

      let handleFileSelector = function() {

        let srcFiles = elmFileSelector.files;

        if (srcFiles.length > 0) {
          elmFileSelector.disabled = true;

          let promisesForFiles = [];

          for (let i = 0; i < srcFiles.length; i ++) {
            let f = srcFiles[i];
            let key = f.name;
            promisesForFiles.push( f.text().then((val) => {progFragments[ key ] = val}) );
          };

          Promise.all(promisesForFiles).then((val) => {elmFileSelector.disabled = false});
        };
      };

      let evaluateSingleFragment = function(arrForPrompt, progFragment) {
        let prefixText  = "";
            prefixText += "let arrForPrompt = " + JSON.stringify(arrForPrompt) + ";\n";
            prefixText += "let prompt = function(){ return arrForPrompt.shift(); };\n";
            prefixText += "let arrForAlert = [];\n";
            prefixText += "let alert = function(v){ arrForAlert.push(v)};\n";

        let postfixText  = "";
            postfixText += "let result = {};\n";
            postfixText += "result.prompt = arrForPrompt;\n";
            postfixText += "result.alert = arrForAlert;\n";
            postfixText += "return result;\n";

        let compositeText = prefixText + progFragment + postfixText;

        let result = null;
        let pr = new Promise((resolve, reject) => {
          let wk = new Worker("worker.js");
          let stp = function() {
            wk.terminate();
            wk = null;
            result = {};
            result.error = "timeout";
            resolve(result);
          };
          let brk = setTimeout(stp, 1000);
          wk.onmessage = function(evt) {
            clearTimeout(brk);
            wk.terminate();
            result = JSON.parse(evt.data);
            resolve(result);
          };
          wk.postMessage(compositeText);
        });
        return pr;
      };


      let enqueEvaluationForTD = function(jsonForPrompt, fragment, elmTR, resolve) {
        if (jsonForPrompt.length > 0) {
          evaluateSingleFragment(jsonForPrompt.shift(), fragment)
          .then((result) => {

            let elmTD = document.createElement("td");
            elmTR.appendChild(elmTD);

            let txtRESULT = null;
            if (result.alert && result.alert.length > 0) {
              txtRESULT = document.createTextNode(result.alert[0]);
            } else {
              txtRESULT = document.createTextNode(result.error);
            };
            elmTD.appendChild(txtRESULT);

            enqueEvaluationForTD(jsonForPrompt, fragment, elmTR, resolve);
          });
        } else {
          resolve();
        };
      };

      let enqueEvaluationForTR = function(objToDo) {
        let prTR = new Promise((resolveTR, rejectTR) => {
          // append elmTR after all cells are created to prevent broken layout
          let elmTR = document.createElement("tr");

          let elmTH = document.createElement("th");
          elmTR.appendChild(elmTH);

          let name_filtered = objToDo.name.replace(/_[0-9]{4}(-[0-9]{2}){5}\.js/, ""); // remove date-time.js suffix
          let txtNAME = document.createTextNode(name_filtered);
          elmTH.appendChild(txtNAME);

          let jsonForPrompt = JSON.parse(strJsonForPrompt);

          let prTD = new Promise((resolveTD, rejectTD) => {
            enqueEvaluationForTD(jsonForPrompt, objToDo.fragment, elmTR, resolveTD);
          });
          prTD.then(() => {
            elmTBODY.appendChild(elmTR);
          });
          resolveTR();
        });
        return prTR;
      };

      let enqueEvaluation = function(arrToDo) {
        if (arrToDo.length > 0) {
          let objToDo = arrToDo.shift();

          let prTR = enqueEvaluationForTR(objToDo);
          prTR.then(() => {
            enqueEvaluation(arrToDo);
          });
        };
      };

      let prepareTHEAD = function() {
        let elmTR = document.createElement("tr");

        let elmTH = document.createElement("th");
        let txt = document.createTextNode("id");
        elmTR.appendChild(elmTH);
        elmTH.appendChild(txt);

        {
          let jsonForPrompt = JSON.parse(strJsonForPrompt);
          while (jsonForPrompt.length > 0) {
            let elmTH = document.createElement("th");
            let txt = document.createTextNode(jsonForPrompt.shift().join(";"));
            elmTH.appendChild(txt);
            elmTR.appendChild(elmTH);
          };
        }

        elmTHEAD.appendChild(elmTR);
      };


      let evaluateFragments = function() {
        if (elmInputDataAsJson.checked) {
          strJsonForPrompt = elmInputForPrompt.value;
        } else
        if (elmInputDataAsCsv.checked) {
          let jsonForPrompt = elmInputForPrompt.value.split(/\s*,\s*/).map((v) => { return [v] });
          strJsonForPrompt = JSON.stringify(jsonForPrompt);
        };

        while (elmTHEAD.lastChild) { 
          elmTHEAD.removeChild(elmTHEAD.lastChild);
        };
        prepareTHEAD();

        while (elmTBODY.lastChild) {
          elmTBODY.removeChild(elmTBODY.lastChild);
        };

        let arrToDo = [];
        for (const [k, v] of Object.entries( progFragments ) ) {
          let objToDo = {};
          objToDo.name = k;
          objToDo.fragment = v;
          arrToDo.push(objToDo);
        };

        enqueEvaluation(arrToDo);
      };

      let updatePlaceHolderText = function() {
        if (elmInputDataAsJson.checked) {
          elmInputForPrompt.placeholder = '[["test1-prompt1", "test1-prompt2"], ["test2-prompt1", ...], ... ]'
        } else
        if (elmInputDataAsCsv.checked) {
          elmInputForPrompt.placeholder = '"test1-prompt", "test2-prompt", ...'
        };
      };

      elmFileSelector.addEventListener("change", handleFileSelector);
      elmStartEvaluate.addEventListener("click", evaluateFragments);
      elmInputDataAsCsv.addEventListener("change", updatePlaceHolderText);
      elmInputDataAsJson.addEventListener("change", updatePlaceHolderText);
    </script>
  </body>
</html>


